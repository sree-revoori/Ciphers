from collections import Counter 
#Helper Methods
def c2i(c, alphabet) : 
  return alphabet.index(c) 
  
def i2c(i, alphabet) :
  return alphabet[i]
  
def prepare_string(s, alphabet) :
  temp = s 
  alphaList = list(alphabet)
  sList = list(temp)
  for index in range(len(sList)) : 
    for index2 in range(len(alphaList)) : 
      if temp[index] == alphaList[index2] :
        break
      if index2 + 1 == len(alphaList) :
        sList.remove(temp[index])
    
  final = ''.join(sList)
  return final
  
  #encoding
  def caesar_shift_encode(plaintext, shift, alphabet) :
  plaintext = plaintext.upper()
  temp = prepare_string(plaintext, alphabet) 
  string = ""
  newChar = ""
  for character in temp : 
    aIndex = c2i(character, alphabet) 
    newIndex = c2i(character, alphabet) + shift 
    if newIndex >= 25 : 
      tempIndex = 25 - aIndex 
      newIndex = shift - tempIndex - 1 
      newChar = i2c(newIndex, alphabet)
    else :
      newChar = i2c(newIndex, alphabet) 
    string += newChar
  return string
  
  # decoding
  def caesar_shift_decode(ciphertext, shift, alphabet) : 
  temp = ciphertext
  string = "" 
  newChar = ""
  for character in temp : 
    newIndex = c2i(character, alphabet) - shift
    newChar = i2c(newIndex, alphabet)
    string += newChar
  return string
  def subst_validate(alpha1, alpha2) : 
  alpha1 = list(alpha1)
  alpha2 = list(alpha2)
  for index in range(len(alpha1)) : 
    for index2 in range(len(alpha2)) : 
      if alpha1[index] == alpha2[index2] :
        break
      
    return False 
  return True 
  # encodes sub cipher using helper method from above
  def substitution_cipher_encode(plaintext, alpha1, alpha2) : 
  temp = prepare_string(plaintext, alpha1)
  subst_validate(alpha1, alpha2)
  ciphertext = ""
  for character in temp : 
    alpha1Index = c2i(character, alpha1)
    shift = alpha1Index
    alpha2Character = i2c(shift, alpha2)
    ciphertext += alpha2Character
  return ciphertext
def substitution_cipher_decode(ciphertext, alpha1, alpha2) : 
  temp = prepare_string(ciphertext, alpha2)
  subst_validate(alpha1, alpha2)
  plaintext = "" 
  for character in temp : 
    alpha2Index = c2i(character, alpha2)
    shift = alpha2Index
    alpha1Character = i2c(shift, alpha1)
    plaintext += alpha1Character
  return plaintext
  #Practically an inverse to the sub cipher encode method
  
    
def make_cipher_alphabet(alphabet, keyword) : 
  keywordList = list(keyword)
  alphbetList = list(alphabet)
  replicate = ""
  cipherAlphabet = ""
  for index in range(len(keywordList)) : 
    if keywordList[index] not in cipherAlphabet : 
      cipherAlphabet += keywordList[index]
  
  for index2 in range(len(alphbetList)) : 
    if alphbetList[index2] not in cipherAlphabet : 
      cipherAlphabet += alphbetList[index2]
      
  return cipherAlphabet
  # This method creates a substitution alphabet to replace the normal english alphabet in the substitution cipher
  def keyword_substitution_cipher_encode(plaintext, keyword, alphabet_source) : 
  plaintext = prepare_string(plaintext.upper(), alphabet_source)
  cipherAlphabet = make_cipher_alphabet(alphabet_source, keyword)
  cipherText = ""
  for character in plaintext : 
    alpha1Index = c2i(character, alphabet_source)
    alpha2Character = i2c(alpha1Index, cipherAlphabet)
    cipherText += alpha2Character
  return cipherText
  
  def keyword_substitution_cipher_decode(ciphertext, keyword, alphabet_source) : 
  # Inverts the encoding method
  cipherAlphabet = make_cipher_alphabet(alphabet_source, keyword)
  #temp = prepare_string(ciphertext, cipherAlphabet)
  plaintext = "" 
  for character in ciphertext : 
    alpha2Index = c2i(character, cipherAlphabet)
    shift = alpha2Index
    alpha1Character = i2c(shift, alphabet_source)
    plaintext += alpha1Character
  return plaintext
  
  def frequent_letters(text, alphabet) : 
    text = prepare_string(text, alphabet)
    c = Counter(text)
    return c.most_common(4)
    
  def frequent_bigraphs(text, alphabet) : 
    bigraphs = []
    for index in range(len(text) - 1) : 
      bigraphs.append(text[index:index + 2])
    c = Counter(bigraphs)
    return c.most_common(4)
   
 def frequent_trigraphs(text, alphabet) : 
  bigraphs = []
  for index in range(len(text) - 1) : 
    bigraphs.append(text[index:index + 3])
  c = Counter(bigraphs)
  return c.most_common(4)
  
  def frequent_double_letters(text, alphabet) :
  double = []
  for index in range(len(text) - 1) : 
    if text[index] == text[index + 1] :
      double.append(text[index] + text[index + 1])
  c = Counter(double)
  return c.most_common(4)
   
  
