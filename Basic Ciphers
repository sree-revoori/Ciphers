from collections import Counter 
#Helper Methods
def c2i(c, alphabet) : 
  return alphabet.index(c) 
  
def i2c(i, alphabet) :
  return alphabet[i]
  
def prepare_string(s, alphabet) :
  temp = s 
  alphaList = list(alphabet)
  sList = list(temp)
  for index in range(len(sList)) : 
    for index2 in range(len(alphaList)) : 
      if temp[index] == alphaList[index2] :
        break
      if index2 + 1 == len(alphaList) :
        sList.remove(temp[index])
    
  final = ''.join(sList)
  return final
  
  #encoding
  def caesar_shift_encode(plaintext, shift, alphabet) :
  plaintext = plaintext.upper()
  temp = prepare_string(plaintext, alphabet) 
  string = ""
  newChar = ""
  for character in temp : 
    aIndex = c2i(character, alphabet) 
    newIndex = c2i(character, alphabet) + shift 
    if newIndex >= 25 : 
      tempIndex = 25 - aIndex 
      newIndex = shift - tempIndex - 1 
      newChar = i2c(newIndex, alphabet)
    else :
      newChar = i2c(newIndex, alphabet) 
    string += newChar
  return string
  
  # decoding
  def caesar_shift_decode(ciphertext, shift, alphabet) : 
  temp = ciphertext
  string = "" 
  newChar = ""
  for character in temp : 
    newIndex = c2i(character, alphabet) - shift
    newChar = i2c(newIndex, alphabet)
    string += newChar
  return string
  def subst_validate(alpha1, alpha2) : 
  alpha1 = list(alpha1)
  alpha2 = list(alpha2)
  for index in range(len(alpha1)) : 
    for index2 in range(len(alpha2)) : 
      if alpha1[index] == alpha2[index2] :
        break
      
    return False 
  return True 
  # encodes sub cipher using helper method from above
  def substitution_cipher_encode(plaintext, alpha1, alpha2) : 
  temp = prepare_string(plaintext, alpha1)
  subst_validate(alpha1, alpha2)
  ciphertext = ""
  for character in temp : 
    alpha1Index = c2i(character, alpha1)
    shift = alpha1Index
    alpha2Character = i2c(shift, alpha2)
    ciphertext += alpha2Character
  return ciphertext

