import math 
from random import randint 

def c2i(c, alphabet):
    return alphabet.index(c)  
    
def i2c(i, alphabet):
    return alphabet[i]
    
def prepare_string(s, alphabet) :
  temp = s 
  alphaList = list(alphabet)
  sList = list(temp)
  for index in range(len(sList)) : 
    for index2 in range(len(alphaList)) : 
      if temp[index] == alphaList[index2] :
        break
      if index2 + 1 == len(alphaList) :
        sList.remove(temp[index])
    
  final = ''.join(sList)
  return final
  
  def mod_inverse(a, m): 
  for number in range(0, m) : 
    temp = (number * a) % m
    if temp == 1 :
      return number
  print("Error: No possible inverse")
  return -1
  
  def miller_rabin_test(p): 
  if (p % 2) == 0: 
    #print("Number is composite")
    return False 
  #finding d such that p-1 = 2**r * d and d is odd 
  r, d = 0, p - 1 
  while(d%2 == 0) : 
    d = d//2 
    r = r + 1
    
  d = int(d)
  
  for index in range(1, 10) : 
    x = pow(randint(2, p-1), d, p)
    if (x == p - 1 or x == 1): 
      continue
    for r in range(1, r) : 
      x = (x * x) % p
      if(x == p) : 
        return False 
      if(x == p - 1) : 
        break 
    else : 
      return False 
  return True 
  
  def totient(num) : 
  totient = 0 
  for index in range(1, num) : #works better with smaller numbers
    if math.gcd(index, num) == 1: 
      totient = totient + 1
  return totient
  
  def calc_d(n, m) : 
  #print(str(greenList))
  
  
  
  
  
  
    

