import math 
from random import randint 

def c2i(c, alphabet):
    return alphabet.index(c)  
    
def i2c(i, alphabet):
    return alphabet[i]
    
def prepare_string(s, alphabet) :
  temp = s 
  alphaList = list(alphabet)
  sList = list(temp)
  for index in range(len(sList)) : 
    for index2 in range(len(alphaList)) : 
      if temp[index] == alphaList[index2] :
        break
      if index2 + 1 == len(alphaList) :
        sList.remove(temp[index])
    
  final = ''.join(sList)
  return final
  
  def mod_inverse(a, m): 
  for number in range(0, m) : 
    temp = (number * a) % m
    if temp == 1 :
      return number
  print("Error: No possible inverse")
  return -1
  
  def miller_rabin_test(p): 
  if (p % 2) == 0: 
    #print("Number is composite")
    return False 
  #finding d such that p-1 = 2**r * d and d is odd 
  r, d = 0, p - 1 
  while(d%2 == 0) : 
    d = d//2 
    r = r + 1
    
  d = int(d)
  
  for index in range(1, 10) : 
    x = pow(randint(2, p-1), d, p)
    if (x == p - 1 or x == 1): 
      continue
    for r in range(1, r) : 
      x = (x * x) % p
      if(x == p) : 
        return False 
      if(x == p - 1) : 
        break 
    else : 
      return False 
  return True 
  
  def totient(num) : 
  totient = 0 
  for index in range(1, num) : #works better with smaller numbers
    if math.gcd(index, num) == 1: 
      totient = totient + 1
  return totient
  
  def calc_d(n, m) : 
  #print(str(greenList))
  
  a, b, u = 0, m, 1
  while n > 0 : 
      q = b // n # integer division
      n, a, b, u = b % n, u, n, a - q * u
  if b == 1 : 
      return a % m 
      
  def rsa(num, plaintext, alphabet) : 
  lowerBound = num - 1
  upperBound = num
  print("Your choice of low bound is two to the following power: " + str(lowerBound))
  print("Your choice of upper bound is two to the following power: " + str(upperBound))
  
  randomPrime1 = randint(pow(2, lowerBound), pow(2, upperBound))
  randomPrime2 = randint(pow(2, lowerBound), pow(2, upperBound))
  
  while(miller_rabin_test(randomPrime1)) == False : 
    randomPrime1 = randint(pow(2, lowerBound), pow(2, upperBound))
  while(miller_rabin_test(randomPrime2)) == False : 
    randomPrime2 = randint(pow(2, lowerBound), pow(2, upperBound))
    

  
  
  
  
      
  
  
  
  
  
  
  
    

